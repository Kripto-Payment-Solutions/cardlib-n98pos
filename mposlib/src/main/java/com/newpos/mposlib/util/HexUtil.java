/**
 * Generated by smali2java 1.0.0.558
 * Copyright (C) 2013 Hensence.com
 */

package com.newpos.mposlib.util;

public class HexUtil {

    public static String toASCII(byte[] data) throws IllegalArgumentException {
        if(data == null) {
            return null;
        }
        if(data.length == 0) {
            return "";
        }
        StringBuffer buff = new StringBuffer();
        for(int i = 0x0; i < data.length; i = i + 0x1) {
            if(data[i] == -0x1) {
                buff.append("F");
            } else if((data[i] >= 0x20) && (data[i] <= 0x7e)) {
                buff.append((char)data[i]);
                continue;
            } else {
                throw new IllegalArgumentException("无法转为可见的ASCII字符");
             }
        }
        return buff.toString();
    }

    public static byte[] toByte(String asc) {
        if((asc == null) || (asc.trim().equals(""))) {
            return null;
        }
        return asc.getBytes();
    }

    public static String toString(byte[] bcd) {
        return StringUtil.byte2HexStr(bcd);
    }

    public static boolean isBCD(String bcd) {
        boolean ans = false;
        bcd = bcd.toUpperCase();
        for(int i = 0x0; i < bcd.length(); i = i + 0x1) {
            ans = true;
            char c = bcd.charAt(i);
            if((c == 0x30) || (c == 0x31) || (c == 0x32) || (c == 0x33) || (c == 0x34) || (c == 0x35) || (c == 0x36) || (c == 0x37) || (c == 0x38) || (c == 0x39) || (c == 0x41) || (c == 0x42) || (c == 0x43) || (c == 0x44) || (c == 0x45) || (c == 0x46)) {
                return ans;
            }
        }
        return ans;
    }

    public static byte[] toBCD(byte[] asc) throws IllegalArgumentException {
        if(asc == null) {
            return null;
        }
        int len = asc.length;
        byte[] tmp = null;
        if((len % 0x2) != 0) {
            tmp = new byte[(len + 0x1)];
            for(int i = 0x0; i < asc.length; i = i + 0x1) {
                tmp[i] = asc[i];
            }
            tmp[len] = 0x0;
        } else {
            tmp = new byte[len];
            for(int i = 0x0; i < asc.length; i = i + 0x1) {
                tmp[i] = asc[i];
            }
        }
        byte[] bcd = new byte[(tmp.length / 0x2)];
        for(int p = 0x0; p < (tmp.length / 0x2); p = p + 0x1) {
            int j = 0x0;
            if(tmp[(p * 0x2)] == 0) {
                j = 0x0;
            } else if(tmp[(p * 0x2)] == 0xf) {
                j = 0xf;
            } else if((tmp[(p * 0x2)] >= 0x30) && (tmp[(p * 0x2)] <= 0x39)) {
                j = tmp[(p * 0x2)] - 0x30;
            } else if((tmp[(p * 0x2)] == 0x61) || (tmp[(p * 0x2)] == 0x41)) {
                j = 0xa;
            } else if((tmp[(p * 0x2)] == 0x62) || (tmp[(p * 0x2)] == 0x42)) {
                j = 0xb;
            } else if((tmp[(p * 0x2)] == 0x63) || (tmp[(p * 0x2)] == 0x43)) {
                j = 0xc;
            } else if((tmp[(p * 0x2)] == 0x44) || (tmp[(p * 0x2)] == 0x64) || (tmp[(p * 0x2)] == 0x3d)) {
                j = 0xd;
            } else if((tmp[(p * 0x2)] == 0x65) || (tmp[(p * 0x2)] == 0x45)) {
                j = 0xe;
            } else if((tmp[(p * 0x2)] == 0x66) || (tmp[(p * 0x2)] == 0x46)) {
                j = 0xf;
            } else {
                throw new IllegalArgumentException("\u975eBCD\u5b57\u8282");
            }
            int k = 0x0;
            if(tmp[((p * 0x2) + 0x1)] == 0) {
                k = 0x0;
            } else if(tmp[((p * 0x2) + 0x1)] == 0xf) {
                k = 0xf;
            } else if((tmp[((p * 0x2) + 0x1)] >= 0x30) && (tmp[((p * 0x2) + 0x1)] <= 0x39)) {
                k = tmp[((p * 0x2) + 0x1)] - 0x30;
            } else if((tmp[((p * 0x2) + 0x1)] == 0x61) || (tmp[((p * 0x2) + 0x1)] == 0x41)) {
                k = 0xa;
            } else if((tmp[((p * 0x2) + 0x1)] == 0x62) || (tmp[((p * 0x2) + 0x1)] == 0x42)) {
                k = 0xb;
            } else if((tmp[((p * 0x2) + 0x1)] == 0x63) || (tmp[((p * 0x2) + 0x1)] == 0x43)) {
                k = 0xc;
            } else if((tmp[((p * 0x2) + 0x1)] == 0x44) || (tmp[((p * 0x2) + 0x1)] == 0x64) || (tmp[((p * 0x2) + 0x1)] == 0x3d)) {
                k = 0xd;
            } else if((tmp[((p * 0x2) + 0x1)] == 0x65) || (tmp[((p * 0x2) + 0x1)] == 0x45)) {
                k = 0xe;
            } else if((tmp[((p * 0x2) + 0x1)] == 0x66) || (tmp[((p * 0x2) + 0x1)] == 0x46)) {
                k = 0xf;
            } else {
                throw new IllegalArgumentException("\u975eBCD\u5b57\u8282");
            }
            int a = (j << 0x4) + k;
            byte b = (byte)a;
            bcd[p] = b;
        }
        return bcd;
    }

    public static byte[] toBCD(String asc) throws IllegalArgumentException {
        if ((asc == null) || (asc.trim().equals("")))
            return null;
        String str = asc.replace('=', 'D').toUpperCase();
        if (!isBCD(str))
            throw new IllegalArgumentException("非BCD字符串");
        return toBCD(str.getBytes());
    }

    public static byte ByteToBcd(int n) {
        int ret = ((n / 0xa) << 0x4) | (n % 0xa);
        return (byte)(ret & 0xff);
    }

    public static String ByteToBcd2Str(byte[] n) {
        StringBuilder sb = new StringBuilder();
        for(int i = 0x0; i < n.length; i = i + 0x1) {
            int ret = ((n[i] / 0xa) << 0x4) | (n[i] % 0xa);
            sb.append((byte)(ret & 0xff));
        }
        return sb.toString().trim();
    }

    public static void printBCD(String bcd) {
        if((bcd == null) || (bcd.trim().equals(""))) {
            throw new NullPointerException("\u6253\u5370\u7684BCD\u5b57\u7b26\u4e32\u4e3aNULL");
        }
        if(!isBCD(bcd)) {
            throw new IllegalArgumentException("\u975eBCD\u5b57\u7b26\u4e32");
        }
        for(int i = 0x0; i < bcd.length(); i = i + 0x1) {
            if((i > 0) && ((i % 0x2) == 0)) {
            }
        }
    }

    public static void printBCD(String tip, String bcd) {
        if((bcd == null) || (bcd.trim().equals(""))) {
            throw new NullPointerException("\u6253\u5370\u7684BCD\u5b57\u7b26\u4e32\u4e3aNULL");
        }
        if(!isBCD(bcd)) {
            throw new IllegalArgumentException("\u975eBCD\u5b57\u7b26\u4e32");
        }
        for(int i = 0x0; i < bcd.length(); i = i + 0x1) {
            if((i > 0) && ((i % 0x2) == 0)) {
            }
        }
    }

    public static String lenToHex(int l) {
        String d = Integer.toHexString(Integer.valueOf(l).intValue()).toUpperCase();
        return d.length() != 0x2 ? "0" + d : d;
    }

    public static byte[] lenTo2Hex(int l) {
        byte[] r = new byte[0x2];
        byte[] bytes = StringUtil.hexStr2Bytes(Integer.toHexString(l).toUpperCase());
        if(bytes.length == 0x1) {
            r[0x1] = bytes[0x0];
            r[0x0] = 0x0;
            return r;
        }
        r[0x0] = bytes[0x1];
        r[0x1] = bytes[0x0];
        return r;
    }

    public String asc2bcd(byte[] asc) {
        StringBuffer localStringBuffer = new StringBuffer();
        int i = asc.length;
        for (int j = 0; j < i; j++)
            localStringBuffer.append(0x7F & asc[j]);
        return localStringBuffer.toString();
    }
}
